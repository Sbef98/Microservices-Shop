sensor : {info:sensore, data : {id: id,  description : description, measured : {value1 : [value,...], value2 : [value,...], ...}, wanted : {value1 : value, value2 : value, ...} } }

actuator : {info : auttuatore, data : { id: id,  description : description, active : {value1 : active_value, value2 : active_value,...}, suggested : {value1 : value, value2: value, ...}, needed_sensors : howToGetTheRightInfo } }


Info = URI, port, type, getMapping (opzionale), putMapping (opzionale)

DOMtype = {sensor, actuator}

if, in needed_sensors, sensorName = *, it means this value from all sensors!
howToGetTheRightInfo possible approach:

needed_sensors : {sensor_name : 		    {sensor's data we look for : {other_sensor_directions, ...}, ... }, ...}
		 ^ The sensor we need the values of  ^what type (eg: Â°C)	 ^ the wanted/suggested values for that data_type pointed by the other sensors

Add group id for the sensors

################################################# NEW MODEL ################################################################
Sensore:
   {
	URI : uri, port : xxxx, type : "sensor"/"actuator", GetMapping : "/xxx/", PutMapping : "/yyy/",   # General informations (GetMapping and PutMapping are optional)-
	groupID : "id", description : "Some description",						  # For group detection
													  # Next is the actual data
	values : {value1 : [value,...], value2 : [value,...], ...},					  # What the sensor is measuring at the time of the update
	wanted : {value1 : value, value2 : value, ...}							  # What the sensor tells the Decision service to confront the data to
   }

Attuatore:
   {
	URI : uri, port : xxxx, type : "sensor"/"actuator", GetMapping : "/xxx/", PutMapping : "/yyy/",
	groupID : "id", description : "Some description",
	values : {value1 : active_value, value2 : active_value,...}, 
	wanted : {value1 : value, value2: value, ...}, 						  	  # Do we need this for real?
													  # And now the needed sensors!
	needed_sensors : {sensor_name : {sensor's data we look for : [other_sensor_directions, ...], ... }, ...} <- the only difference with the sensor
   }

For the other_sensor_direction we could actually just use the groupid. The actuators will use the directions give by all the services in their own groupid!

Given the similarities between Senors and actuators, i think we should implement a class Service, which specializes into Sensor and Actuator

DecisionService's answer: 
    {
	sensor_name : { valueName : { delta between wanted value and active value }, ... } , ...
    }

ROBA DA FARE:
- Ottimizzazione JSON e incapsulamento;
- Eliminare la differenza tra attuatore e sensore --> Diventano tutti servizi;
- Other_sensor_directions diventano "comparator_services";
- Esportare dal decisore le connessioni disponibili --> Richiesta diretta dati sensore;
- Generare uno storico dei vari sensori;
- Gestione collisioni nel decisore;

-- Funzione di ovverride per l'algoritmo decisionale sul decisore;